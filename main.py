import os
import javalang
import argparse
import json
from collections import defaultdict

def parse_java_file(file_path):
    """Parsea un archivo Java y devuelve su representación parseada."""
    try:
        with open(file_path, 'r', encoding='utf-8') as file:
            return javalang.parse.parse(file.read())
    except (javalang.parser.JavaSyntaxError, FileNotFoundError, UnicodeDecodeError) as e:
        print(f"Error al parsear el archivo {file_path}: {e}")
        return None

def get_package_name(parsed_tree):
    """Obtiene el nombre del paquete de un árbol parseado."""
    return parsed_tree.package.name if parsed_tree.package else ''

def get_full_class_name(package_name, class_name):
    """Construye el nombre completo de una clase incluyendo el paquete."""
    return f"{package_name}.{class_name}" if package_name else class_name

def get_type_name(type_obj):
    """Obtiene el nombre de tipo completo, considerando tipos genéricos."""
    if isinstance(type_obj, javalang.tree.ReferenceType):
        # Maneja tipos genéricos simplificados
        return '.'.join(type_obj.name) if isinstance(type_obj.name, list) else type_obj.name
    elif isinstance(type_obj, javalang.tree.BasicType):
        return type_obj.name
    else:
        return str(type_obj)

def has_lombok_annotation(annotations, annotation_names):
    """Verifica si las anotaciones incluyen alguna de las específicas de Lombok."""
    for annotation in annotations:
        if annotation.name in annotation_names:
            return True
    return False

def extract_attributes_and_constructors(class_node):
    """Extrae atributos y constructores de un nodo de clase, considerando anotaciones de Lombok."""
    attributes = []
    constructors = []

    # Anotaciones de Lombok que generan constructores
    lombok_constructor_annotations = {"NoArgsConstructor", "AllArgsConstructor"}

    for member in class_node.body:
        if isinstance(member, javalang.tree.FieldDeclaration):
            field_type = get_type_name(member.type)
            for decl in member.declarators:
                attributes.append((decl.name, field_type))
        elif isinstance(member, javalang.tree.ConstructorDeclaration):
            constructors.append({
                "name": class_node.name,
                "parameters": [(param.name, get_type_name(param.type)) for param in member.parameters]
            })

    # Verificar anotaciones de clase para constructores generados por Lombok
    if has_lombok_annotation(class_node.annotations, lombok_constructor_annotations):
        constructors.append({
            "name": class_node.name,
            "parameters": "Generated by Lombok"
        })

    return attributes, constructors

def build_class_index(base_path):
    """
    Recorre el sistema de archivos una vez para construir un índice de clases.
    Devuelve un diccionario que mapea nombres completos de clases a sus rutas de archivo.
    """
    class_index = {}
    for root, _, files in os.walk(base_path):
        for file_name in files:
            if file_name.endswith(".java"):
                file_path = os.path.join(root, file_name)
                parsed_tree = parse_java_file(file_path)
                if parsed_tree is None:
                    continue
                package_name = get_package_name(parsed_tree)
                for _, node in parsed_tree.filter(javalang.tree.ClassDeclaration):
                    full_class_name = get_full_class_name(package_name, node.name)
                    class_index[full_class_name] = file_path
    return class_index

def find_class_dependencies(class_index, class_name, visited_classes=None):
    """Encuentra atributos, constructores y características heredadas de una clase de forma recursiva."""
    if visited_classes is None:
        visited_classes = set()

    if class_name in visited_classes:
        return {}

    visited_classes.add(class_name)

    file_path = class_index.get(class_name)
    if not file_path:
        # Clase no encontrada en el índice
        return {}

    parsed_tree = parse_java_file(file_path)
    if not parsed_tree:
        return {}

    # Obtener el nodo de la clase
    target_class_simple_name = class_name.split('.')[-1]
    class_node = None
    package_name = get_package_name(parsed_tree)
    for _, node in parsed_tree.filter(javalang.tree.ClassDeclaration):
        if node.name == target_class_simple_name:
            class_node = node
            break

    if not class_node:
        return {}

    attributes, constructors = extract_attributes_and_constructors(class_node)
    class_data = {
        "attributes": attributes,
        "constructors": constructors,
        "dependencies": {}
    }

    # Verificar herencia (extends)
    if class_node.extends:
        superclass_name = get_type_name(class_node.extends)
        # Resolver el nombre completo de la superclase
        if '.' not in superclass_name:
            # Asumir que está en el mismo paquete si es nombre simple
            superclass_full_name = get_full_class_name(package_name, superclass_name)
        else:
            superclass_full_name = superclass_name

        class_data["superclass"] = superclass_full_name
        # Recursivamente analizar la superclase
        dependencies = find_class_dependencies(class_index, superclass_full_name, visited_classes)
        class_data["dependencies"].update(dependencies)

    # Analizar dependencias de atributos
    for attr_name, attr_type in attributes:
        # Resolver el nombre completo del tipo de atributo
        if '.' not in attr_type and attr_type not in {"int", "long", "double", "float", "boolean", "char", "byte", "short", "void"}:
            # Asumir que está en el mismo paquete si es nombre simple y no un tipo básico
            attr_full_name = get_full_class_name(package_name, attr_type)
        else:
            attr_full_name = attr_type

        dependencies = find_class_dependencies(class_index, attr_full_name, visited_classes)
        class_data["dependencies"].update(dependencies)

    return {class_name: class_data}

def main():
    # Parsear argumentos de línea de comandos
    parser = argparse.ArgumentParser(description="Analiza clases Java y sus dependencias.")
    parser.add_argument("base_path", type=str, help="Ruta al directorio base del proyecto.")
    parser.add_argument("class_name", type=str, help="Nombre completo de la clase a analizar (incluyendo paquete).")
    args = parser.parse_args()

    base_path = args.base_path
    target_class = args.class_name

    # Construir el índice de clases
    print("Construyendo índice de clases. Esto puede tardar un momento...")
    class_index = build_class_index(base_path)
    print(f"Índice construido. {len(class_index)} clases encontradas.")

    # Encontrar y construir la estructura de dependencia
    print(f"Analizando dependencias para la clase {target_class}...")
    class_structure = find_class_dependencies(class_index, target_class)
    if class_structure:
        print(json.dumps(class_structure, indent=4, ensure_ascii=False))
    else:
        print(f"No se encontró la clase {target_class} en el proyecto.")

if __name__ == "__main__":
    main()